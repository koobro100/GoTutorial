# 文件写入

这段代码实现了生成一个大小为1GB的二进制文件，其中填充了随机生成的31位无符号整数（存储为4字节的uint32）。

```go
package main

import (
	"encoding/binary"
	"fmt"
	"math/rand"
	"os"
	"time"
)

func main() {
	start := time.Now()

	targetFileSize := 1 * 1024 * 1024 * 1024 // 文件大小1GB
	filePath := "test.bin"                   // 文件名
	bytesPerInteger := 4                     // 每个整数占4个字节

	// 初始化缓冲区大小
	bufferSize := 1 * 1024 * 1024
	buffer := make([]byte, bufferSize)

	// 判断文件是否存在
	if _, err := os.Stat(filePath); err == nil {
		fmt.Println("文件已存在，准备删除...")

		if err := os.Remove(filePath); err != nil {
			fmt.Printf("删除文件时发生错误: %v\n", err)
			return
		}
		fmt.Println("文件已成功删除。")
	} else if os.IsNotExist(err) {
		fmt.Println("文件不存在。")
	} else {
		fmt.Printf("检查文件状态时发生错误: %v\n", err)
	}

	// 创建文件
	file, err := os.Create(filePath)
	if err != nil {
		fmt.Println("创建文件失败：", err)
		return
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			panic(err)
		}
	}(file)

	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	for i := range targetFileSize / bufferSize {
		fmt.Println(i + 1)
		for j := 0; j < bufferSize/bytesPerInteger; j++ {
			binary.BigEndian.PutUint32(buffer[j*bytesPerInteger:(j+1)*bytesPerInteger], uint32(r.Int31()))
		}
		_, err = file.Write(buffer)
		if err != nil {
			fmt.Println("写入文件失败：", err)
			return
		}
	}

	end := time.Now()

	duration := end.Sub(start).Seconds()
	formattedDuration := fmt.Sprintf("%.2f", duration)
	fmt.Printf("写入完成，耗时：%s 秒", formattedDuration)
}

```



